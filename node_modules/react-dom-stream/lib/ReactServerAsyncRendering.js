/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactServerAsyncRendering
 */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactElement = require('./ReactElement');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactServerBatchingStrategy = require('./ReactServerBatchingStrategy');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');
var ReactUpdates = require('./ReactUpdates');

var emptyObject = require('fbjs/lib/emptyObject');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');
var isReadableStream = require('./isReadableStream');

var rollingAdler32 = require('./rollingAdler32');
var stream = require('stream');

// this is a pass through stream that can calculate the hash that is used to
// checksum react server-rendered elements.

var Adler32Stream = (function (_stream$Transform) {
  _inherits(Adler32Stream, _stream$Transform);

  function Adler32Stream(rootId, options) {
    var _this = this;

    _classCallCheck(this, Adler32Stream);

    _get(Object.getPrototypeOf(Adler32Stream.prototype), 'constructor', this).call(this, options);
    this.rootId = rootId;
    this.rollingHash = rollingAdler32("");
    this.on("end", function () {
      _this.done = true;
    });
  }

  _createClass(Adler32Stream, [{
    key: '_transform',
    value: function _transform(chunk, encoding, next) {
      this.rollingHash = rollingAdler32(chunk.toString("utf-8"), this.rollingHash);
      this.push(chunk);
      next();
    }
  }, {
    key: '_flush',
    value: function _flush(next) {
      var hash = this.rollingHash.hash();
      var scriptId = this.rootId + '.script';
      this.push('<script type="text/javascript" id="' + scriptId + '">\n        if (!document.querySelector) throw new Error("react-dom-stream requires document.querySelector. If using IE8 or IE9, please make sure you are in standards mode by including <!DOCTYPE html>");\n        document.querySelector(\'[data-reactid="' + this.rootId + '"]\').setAttribute("data-react-checksum", ' + hash + ');\n        var s = document.getElementById("' + scriptId + '");\n        s.parentElement.removeChild(s);\n      </script>');
      next();
    }
  }]);

  return Adler32Stream;
})(stream.Transform);

var RenderStream = (function (_stream$Readable) {
  _inherits(RenderStream, _stream$Readable);

  function RenderStream(componentInstance, id, transaction, context, cache, options, maxStackDepth) {
    _classCallCheck(this, RenderStream);

    _get(Object.getPrototypeOf(RenderStream.prototype), 'constructor', this).call(this, options);
    this.buffer = "";
    this.componentInstance = componentInstance;
    this.id = id;
    this.transaction = transaction;
    this.context = context;
    this.cache = cache;
    this.maxStackDepth = maxStackDepth || 500;
    this.nextTickCalls = 0;
  }

  /**
   * @param {ReactElement} element
   * @return {string} the HTML markup
   */

  _createClass(RenderStream, [{
    key: '_read',
    value: function _read(n) {
      var _this2 = this;

      try {
        var bufferToPush;
        if (this.done) {
          this.push(null);
          return;
        }
        // it's possible that the last chunk added bumped the buffer up to > 2 * n, which means we will
        // need to go through multiple read calls to drain it down to < n.
        if (this.buffer.length >= n) {
          bufferToPush = this.buffer.substring(0, n);
          this.buffer = this.buffer.substring(n);
          this.push(bufferToPush);
          return;
        }

        if (this.stream) {
          var data = this.stream.read(n);
          // if the underlying stream isn't ready, it returns null, so we push a blank string to
          // get it to work.
          if (null === data) {
            this.push("");
          } else {
            this.push(data);
          }
          return;
        }
        // if we have are already rendering and have a continuation to call, do so.
        if (this.continuation) {
          // continue with the rendering.
          this.continuation();
          return;
        }

        this.stackDepth = 0;
        // start the rendering chain.
        this.componentInstance.mountComponentAsync(this.id, this.transaction, this.context, function (text, cb) {
          if (isReadableStream(text)) {
            var _ret = (function () {
              // this is a stream
              _this2.stream = text;
              _this2.stream.on("end", function () {
                _this2.stream = null;
                cb();
              });
              var data = _this2.stream.read(n - _this2.buffer.length);

              setImmediate(function () {
                if (data === null) data = _this2.stream.read(n - _this2.buffer.length);
                _this2.push(_this2.buffer + (data === null ? "" : data));
                _this2.buffer = "";
              });
              return {
                v: undefined
              };
            })();

            if (typeof _ret === 'object') return _ret.v;
          }

          _this2.buffer += text;
          if (_this2.buffer.length >= n) {
            _this2.continuation = cb;
            bufferToPush = _this2.buffer.substring(0, n);
            _this2.buffer = _this2.buffer.substring(n);
            _this2.push(bufferToPush);
          } else {
            // continue rendering until we have enough text to call this.push().
            // sometimes do this as process.nextTick to get out of stack overflows.
            if (_this2.stackDepth >= _this2.maxStackDepth) {
              process.nextTick(cb);
            } else {
              _this2.stackDepth++;
              cb();
              _this2.stackDepth--;
            }
          }
        }, this.cache, function () {
          // the rendering is finished; we should push out the last of the buffer.
          _this2.done = true;
          _this2.push(_this2.buffer);
        });
      } catch (e) {
        this.emit('error', e);
        return;
      }
    }
  }]);

  return RenderStream;
})(stream.Readable);

function renderToStringStream(element) {
  var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var _ref$syncBatching = _ref.syncBatching;
  var syncBatching = _ref$syncBatching === undefined ? false : _ref$syncBatching;
  var cache = _ref.cache;
  var rootID = _ref.rootID;

  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStringStream(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;

  // NOTE that we never change this, which means that client rendering code cannot be used
  // in conjunction with this code.
  ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

  var id = rootID || ReactInstanceHandles.createReactRootID();
  transaction = ReactServerRenderingTransaction.getPooled(false);

  var markupStream = transaction.perform(function () {
    var componentInstance = instantiateReactComponent(element, null);
    return new RenderStream(componentInstance, id, transaction, emptyObject, cache);
  }, null);

  markupStream.on("end", function () {
    ReactServerRenderingTransaction.release(transaction);
    // Revert to the DOM batching strategy since these two renderers
    // currently share these stateful modules.
    // NOTE: THIS SHOULD ONLY BE DONE IN TESTS OR OTHER ENVIRONMENTS KNOWN TO BE SYNCHRONOUS.
    if (syncBatching) ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
  });

  var checksumedStream = markupStream.pipe(new Adler32Stream(id));
  // manually propagate errors down the chain.
  markupStream.on('error', function (e) {
    return checksumedStream.emit('error', e);
  });
  return checksumedStream;
}

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup, without the extra React ID and checksum
 * (for generating static pages)
 */
function renderToStaticMarkupStream(element) {
  var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var cache = _ref2.cache;
  var rootID = _ref2.rootID;

  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkupStream(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;

  // NOTE that we never change this, which means that client rendering code cannot be used
  // in conjunction with this code.
  ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

  var id = rootID || ReactInstanceHandles.createReactRootID();
  transaction = ReactServerRenderingTransaction.getPooled(true);

  var readable = transaction.perform(function () {
    var componentInstance = instantiateReactComponent(element, null);
    return new RenderStream(componentInstance, id, transaction, emptyObject, cache);
  }, null);

  readable.on("end", function () {
    ReactServerRenderingTransaction.release(transaction);
  });

  return readable;
}

module.exports = {
  renderToStringStream: renderToStringStream,
  renderToStaticMarkupStream: renderToStaticMarkupStream
};