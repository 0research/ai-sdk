{"version":3,"sources":["../../src/jsonrepair.js"],"names":["JsonRepairError","insertAtIndex","insertBeforeLastWhitespace","isAlpha","isDigit","isDoubleQuote","isHex","isQuote","isSingleQuote","isSpecialWhitespace","isWhitespace","normalizeQuote","normalizeWhitespace","stripLastOccurrence","DELIMITER","NUMBER","STRING","SYMBOL","WHITESPACE","COMMENT","UNKNOWN","DELIMITERS","ESCAPE_CHARACTERS","b","f","n","r","t","CONTROL_CHARACTERS","SYMBOLS","null","true","false","PYTHON_SYMBOLS","None","True","False","input","output","index","c","token","tokenType","jsonrepair","text","charAt","processNextToken","rootLevelTokenType","parseObject","skipComma","tokenIsStartOfValue","stashedOutput","length","next","nextSkipEscape","tokenIsStartOfKey","getTokenDelimiter","getTokenNumber","getTokenEscapedString","getTokenString","getNext","quote","isEndQuote","unescaped","undefined","u","getTokenAlpha","getTokenWhitespace","getTokenComment","getTokenUnknown","parseArray","parseString","endIndex","lastIndexOf","substring","parseNumber","parseSymbol","symbol","symbolIndex","parseEnd"],"mappings":"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","sourcesContent":["import JsonRepairError from './JsonRepairError.js'\nimport {\n  insertAtIndex,\n  insertBeforeLastWhitespace,\n  isAlpha,\n  isDigit,\n  isDoubleQuote,\n  isHex,\n  isQuote,\n  isSingleQuote,\n  isSpecialWhitespace,\n  isWhitespace,\n  normalizeQuote,\n  normalizeWhitespace,\n  stripLastOccurrence\n} from './stringUtils.js'\n\n// token types enumeration\nconst DELIMITER = 0\nconst NUMBER = 1\nconst STRING = 2\nconst SYMBOL = 3\nconst WHITESPACE = 4\nconst COMMENT = 5\nconst UNKNOWN = 6\n\n/**\n * @typedef {DELIMITER | NUMBER | STRING | SYMBOL | WHITESPACE | COMMENT | UNKNOWN} TokenType\n */\n\n// map with all delimiters\nconst DELIMITERS = {\n  '': true,\n  '{': true,\n  '}': true,\n  '[': true,\n  ']': true,\n  ':': true,\n  ',': true,\n\n  // for JSONP and MongoDB data type notation\n  '(': true,\n  ')': true,\n  ';': true,\n\n  // for string concatenation\n  '+': true\n}\n\n// map with all escape characters\nconst ESCAPE_CHARACTERS = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // \\u is handled by getToken()\n}\n\n// TODO: can we unify CONTROL_CHARACTERS and ESCAPE_CHARACTERS?\nconst CONTROL_CHARACTERS = {\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n}\n\nconst SYMBOLS = {\n  null: 'null',\n  true: 'true',\n  false: 'false'\n}\n\nconst PYTHON_SYMBOLS = {\n  None: 'null',\n  True: 'true',\n  False: 'false'\n}\n\nlet input = '' // current json text\nlet output = '' // generated output\nlet index = 0 // current index in text\nlet c = '' // current token character in text\nlet token = '' // current token\nlet tokenType = UNKNOWN // type of current token\n\n/**\n * Repair a string containing an invalid JSON document.\n * For example changes JavaScript notation into JSON notation.\n *\n * Example:\n *\n *     jsonrepair('{name: \\'John\\'}\") // '{\"name\": \"John\"}'\n *\n * @param {string} text\n * @return {string}\n */\nexport default function jsonrepair (text) {\n  // initialize\n  input = text\n  output = ''\n  index = 0\n  c = input.charAt(0)\n  token = ''\n  tokenType = UNKNOWN\n\n  // get first token\n  processNextToken()\n\n  const rootLevelTokenType = tokenType\n\n  // parse everything\n  parseObject()\n\n  // ignore trailing comma\n  skipComma()\n\n  if (token === '') {\n    // reached the end of the document properly\n    return output\n  }\n\n  if (rootLevelTokenType === tokenType && tokenIsStartOfValue()) {\n    // start of a new value after end of the root level object: looks like\n    // newline delimited JSON -> turn into a root level array\n\n    let stashedOutput = ''\n\n    while (rootLevelTokenType === tokenType && tokenIsStartOfValue()) {\n      output = insertBeforeLastWhitespace(output, ',')\n\n      stashedOutput += output\n      output = ''\n\n      // parse next newline delimited item\n      parseObject()\n\n      // ignore trailing comma\n      skipComma()\n    }\n\n    // wrap the output in an array\n    return `[\\n${stashedOutput}${output}\\n]`\n  }\n\n  throw new JsonRepairError('Unexpected characters', index - token.length)\n}\n\n/**\n * Get the next character from the expression.\n * The character is stored into the char c. If the end of the expression is\n * reached, the function puts an empty string in c.\n */\nfunction next () {\n  index++\n  c = input.charAt(index)\n  // Note: not using input[index] because that returns undefined when index is out of range\n}\n\n/**\n * Special version of the function next, used to parse escaped strings\n */\nfunction nextSkipEscape () {\n  next()\n  if (c === '\\\\') {\n    next()\n  }\n}\n\n/**\n * check whether the current token is the start of a value:\n * object, array, number, string, or symbol\n * @returns {boolean}\n */\nfunction tokenIsStartOfValue () {\n  return (tokenType === DELIMITER && (token === '[' || token === '{')) ||\n    tokenType === STRING ||\n    tokenType === NUMBER ||\n    tokenType === SYMBOL\n}\n\n/**\n * check whether the current token is the start of a key (or possible key):\n * number, string, or symbol\n * @returns {boolean}\n */\nfunction tokenIsStartOfKey () {\n  return tokenType === STRING ||\n    tokenType === NUMBER ||\n    tokenType === SYMBOL\n}\n\n/**\n * Process the previous token, and get next token in the current text\n */\nfunction processNextToken () {\n  output += token\n\n  tokenType = UNKNOWN\n  token = ''\n\n  getTokenDelimiter()\n\n  if (tokenType === WHITESPACE) {\n    // we leave the whitespace as it is, except replacing special white\n    // space character\n    token = normalizeWhitespace(token)\n    processNextToken()\n  }\n\n  if (tokenType === COMMENT) {\n    // ignore comments\n    tokenType = UNKNOWN\n    token = ''\n\n    processNextToken()\n  }\n}\n\nfunction skipComma () {\n  if (token === ',') {\n    token = ''\n    tokenType = UNKNOWN\n    processNextToken()\n  }\n}\n\n// check for delimiters like ':', '{', ']'\nfunction getTokenDelimiter () {\n  if (DELIMITERS[c]) {\n    tokenType = DELIMITER\n    token = c\n    next()\n    return\n  }\n\n  getTokenNumber()\n}\n\n// check for a number like \"2.3e+5\"\nfunction getTokenNumber () {\n  if (isDigit(c) || c === '-') {\n    tokenType = NUMBER\n\n    if (c === '-') {\n      token += c\n      next()\n\n      if (!isDigit(c)) {\n        throw new JsonRepairError('Invalid number, digit expected', index)\n      }\n    } else if (c === '0') {\n      token += c\n      next()\n    } else {\n      // digit 1-9, nothing extra to do\n    }\n\n    while (isDigit(c)) {\n      token += c\n      next()\n    }\n\n    if (c === '.') {\n      token += c\n      next()\n\n      if (!isDigit(c)) {\n        throw new JsonRepairError('Invalid number, digit expected', index)\n      }\n\n      while (isDigit(c)) {\n        token += c\n        next()\n      }\n    }\n\n    if (c === 'e' || c === 'E') {\n      token += c\n      next()\n\n      if (c === '+' || c === '-') {\n        token += c\n        next()\n      }\n\n      if (!isDigit(c)) {\n        throw new JsonRepairError('Invalid number, digit expected', index)\n      }\n\n      while (isDigit(c)) {\n        token += c\n        next()\n      }\n    }\n\n    return\n  }\n\n  getTokenEscapedString()\n}\n\n// get a token string like '\\\"hello world\\\"'\nfunction getTokenEscapedString () {\n  if (c === '\\\\' && input.charAt(index + 1) === '\"') {\n    // an escaped piece of JSON\n    next()\n    getTokenString(nextSkipEscape)\n  } else {\n    getTokenString(next)\n  }\n}\n\n// get a token string like '\"hello world\"'\nfunction getTokenString (getNext) {\n  if (isQuote(c)) {\n    const quote = normalizeQuote(c)\n    const isEndQuote = isSingleQuote(c) ? isSingleQuote : isDoubleQuote\n\n    token += '\"' // output valid double quote\n    tokenType = STRING\n    getNext()\n\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (c !== '' && !isEndQuote(c)) {\n      if (c === '\\\\') {\n        // handle escape characters\n        getNext()\n\n        const unescaped = ESCAPE_CHARACTERS[c]\n        if (unescaped !== undefined) {\n          token += '\\\\' + c\n          getNext()\n        } else if (c === 'u') {\n          // parse escaped unicode character, like '\\\\u260E'\n          token += '\\\\u'\n          getNext()\n\n          for (let u = 0; u < 4; u++) {\n            if (!isHex(c)) {\n              throw new JsonRepairError('Invalid unicode character', index - token.length)\n            }\n            token += c\n            getNext()\n          }\n        } else if (c === '\\'') {\n          // escaped single quote character -> remove the escape character\n          token += '\\''\n          getNext()\n        } else {\n          throw new JsonRepairError('Invalid escape character \"\\\\' + c + '\"', index)\n        }\n      } else if (CONTROL_CHARACTERS[c]) {\n        // unescaped special character\n        // fix by adding an escape character\n        token += CONTROL_CHARACTERS[c]\n        getNext()\n      } else if (c === '\"') {\n        // unescaped double quote -> escape it\n        token += '\\\\\"'\n        getNext()\n      } else {\n        // a regular character\n        token += c\n        getNext()\n      }\n    }\n\n    if (normalizeQuote(c) !== quote) {\n      throw new JsonRepairError('End of string expected', index - token.length)\n    }\n    token += '\"' // output valid double quote\n    getNext()\n\n    return\n  }\n\n  getTokenAlpha()\n}\n\n// check for symbols (true, false, null)\nfunction getTokenAlpha () {\n  if (isAlpha(c)) {\n    tokenType = SYMBOL\n\n    while (isAlpha(c) || isDigit(c) || c === '$') {\n      token += c\n      next()\n    }\n\n    return\n  }\n\n  getTokenWhitespace()\n}\n\n// get whitespaces: space, tab, newline, and carriage return\nfunction getTokenWhitespace () {\n  if (isWhitespace(c) || isSpecialWhitespace(c)) {\n    tokenType = WHITESPACE\n\n    while (isWhitespace(c) || isSpecialWhitespace(c)) {\n      token += c\n      next()\n    }\n\n    return\n  }\n\n  getTokenComment()\n}\n\nfunction getTokenComment () {\n  // find a block comment '/* ... */'\n  if (c === '/' && input[index + 1] === '*') {\n    tokenType = COMMENT\n\n    while (c !== '' && (c !== '*' || (c === '*' && input[index + 1] !== '/'))) {\n      token += c\n      next()\n    }\n\n    if (c === '*' && input[index + 1] === '/') {\n      token += c\n      next()\n\n      token += c\n      next()\n    }\n\n    return\n  }\n\n  // find a comment '// ...'\n  if (c === '/' && input[index + 1] === '/') {\n    tokenType = COMMENT\n\n    while (c !== '' && c !== '\\n') {\n      token += c\n      next()\n    }\n\n    return\n  }\n\n  getTokenUnknown()\n}\n\n// something unknown is found, wrong characters -> a syntax error\nfunction getTokenUnknown () {\n  tokenType = UNKNOWN\n\n  while (c !== '') {\n    token += c\n    next()\n  }\n\n  throw new JsonRepairError('Syntax error in part \"' + token + '\"', index - token.length)\n}\n\n/**\n * Parse an object like '{\"key\": \"value\"}'\n * @return {*}\n */\nfunction parseObject () {\n  if (tokenType === DELIMITER && token === '{') {\n    processNextToken()\n\n    // TODO: can we make this redundant?\n    if (tokenType === DELIMITER && token === '}') {\n      // empty object\n      processNextToken()\n      return\n    }\n\n    while (true) {\n      // parse key\n\n      if (tokenType === SYMBOL || tokenType === NUMBER) {\n        // unquoted key -> add quotes around it, change it into a string\n        tokenType = STRING\n        token = `\"${token}\"`\n      }\n\n      if (tokenType !== STRING) {\n        // TODO: handle ambiguous cases like '[{\"a\":1,{\"b\":2}]' which could be an array with two objects or one\n        throw new JsonRepairError('Object key expected', index - token.length)\n      }\n      processNextToken()\n\n      // parse colon (key/value separator)\n      if (tokenType === DELIMITER && token === ':') {\n        processNextToken()\n      } else {\n        if (tokenIsStartOfValue()) {\n          // we expect a colon here, but got the start of a value\n          // -> insert a colon before any inserted whitespaces at the end of output\n          output = insertBeforeLastWhitespace(output, ':')\n        } else {\n          throw new JsonRepairError('Colon expected', index - token.length)\n        }\n      }\n\n      // parse value\n      parseObject()\n\n      // parse comma (key/value pair separator)\n      if (tokenType === DELIMITER && token === ',') {\n        processNextToken()\n\n        if (tokenType === DELIMITER && token === '}') {\n          // we've just passed a trailing comma -> remove the trailing comma\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n\n        if (token === '') {\n          // end of json reached, but missing }\n          // Strip the missing comma (the closing bracket will be added later)\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n      } else {\n        if (tokenIsStartOfKey()) {\n          // we expect a comma here, but got the start of a new key\n          // -> insert a comma before any inserted whitespaces at the end of output\n          output = insertBeforeLastWhitespace(output, ',')\n        } else {\n          break\n        }\n      }\n    }\n\n    if (tokenType === DELIMITER && token === '}') {\n      processNextToken()\n    } else {\n      // missing end bracket -> insert the missing bracket\n      output = insertBeforeLastWhitespace(output, '}')\n    }\n\n    return\n  }\n\n  parseArray()\n}\n\n/**\n * Parse an object like '[\"item1\", \"item2\", ...]'\n */\nfunction parseArray () {\n  if (tokenType === DELIMITER && token === '[') {\n    processNextToken()\n\n    if (tokenType === DELIMITER && token === ']') {\n      // empty array\n      processNextToken()\n      return\n    }\n\n    while (true) {\n      // parse item\n      parseObject()\n\n      // parse comma (item separator)\n      if (tokenType === DELIMITER && token === ',') {\n        processNextToken()\n\n        if (tokenType === DELIMITER && token === ']') {\n          // we've just passed a trailing comma -> remove the trailing comma\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n\n        if (token === '') {\n          // end of json reached, but missing ]\n          // Strip the missing comma (the closing bracket will be added later)\n          output = stripLastOccurrence(output, ',')\n          break\n        }\n      } else {\n        if (tokenIsStartOfValue()) {\n          // we expect a comma here, but got the start of a new item\n          // -> insert a comma before any inserted whitespaces at the end of output\n          output = insertBeforeLastWhitespace(output, ',')\n        } else {\n          break\n        }\n      }\n    }\n\n    if (tokenType === DELIMITER && token === ']') {\n      processNextToken()\n    } else {\n      // missing end bracket -> insert the missing bracket\n      output = insertBeforeLastWhitespace(output, ']')\n    }\n    return\n  }\n\n  parseString()\n}\n\n/**\n * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\n */\nfunction parseString () {\n  if (tokenType === STRING) {\n    processNextToken()\n\n    while (tokenType === DELIMITER && token === '+') {\n      // string concatenation like \"hello\" + \"world\"\n      token = '' // don't output the concatenation\n      processNextToken()\n\n      if (tokenType === STRING) {\n        // concatenate with the previous string\n        const endIndex = output.lastIndexOf('\"')\n        output = output.substring(0, endIndex) + token.substring(1)\n        token = ''\n        processNextToken()\n      }\n    }\n\n    return\n  }\n\n  parseNumber()\n}\n\n/**\n * Parse a number\n */\nfunction parseNumber () {\n  if (tokenType === NUMBER) {\n    processNextToken()\n    return\n  }\n\n  parseSymbol()\n}\n\n/**\n * Parse constants true, false, null\n */\nfunction parseSymbol () {\n  if (tokenType === SYMBOL) {\n    // a supported symbol: true, false, null\n    if (SYMBOLS[token]) {\n      processNextToken()\n      return\n    }\n\n    // for example replace None with null\n    if (PYTHON_SYMBOLS[token]) {\n      token = PYTHON_SYMBOLS[token]\n      processNextToken()\n      return\n    }\n\n    // make a copy of the symbol, let's see what comes next\n    const symbol = token\n    const symbolIndex = output.length\n    token = ''\n    processNextToken()\n\n    // if (tokenType === DELIMITER && token === '(') {\n    if (tokenType === DELIMITER && token === '(') {\n      // a MongoDB function call or JSONP call\n      // Can be a MongoDB data type like in {\"_id\": ObjectId(\"123\")}\n      // token = '' // do not output the function name\n      // processNextToken()\n\n      // next()\n      token = '' // do not output the ( character\n      processNextToken()\n\n      // process the part inside the brackets\n      parseObject()\n\n      // skip the closing bracket \")\" and \");\"\n      if (tokenType === DELIMITER && token === ')') {\n        token = '' // do not output the ) character\n        processNextToken()\n\n        if (tokenType === DELIMITER && token === ';') {\n          token = '' // do not output the semicolon character\n          processNextToken()\n        }\n      }\n\n      return\n    }\n\n    // unknown symbol => turn into in a string\n    // it is possible that by reading the next token we already inserted\n    // extra spaces in the output which should be inside the string,\n    // hence the symbolIndex\n    output = insertAtIndex(output, `\"${symbol}`, symbolIndex)\n    while (tokenType === SYMBOL || tokenType === NUMBER) {\n      processNextToken()\n    }\n    output += '\"'\n\n    return\n  }\n\n  parseEnd()\n}\n\n/**\n * Evaluated when the expression is not yet ended but expected to end\n */\nfunction parseEnd () {\n  if (token === '') {\n    // syntax error or unexpected end of expression\n    throw new JsonRepairError('Unexpected end of json string', index - token.length)\n  } else {\n    throw new JsonRepairError('Value expected', index - token.length)\n  }\n}\n"],"file":"jsonrepair.js"}