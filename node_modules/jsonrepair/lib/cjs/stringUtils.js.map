{"version":3,"sources":["../../src/stringUtils.js"],"names":["SINGLE_QUOTES","DOUBLE_QUOTES","isAlpha","c","ALPHA_REGEX","test","isHex","HEX_REGEX","isDigit","DIGIT_REGEX","isWhitespace","isSpecialWhitespace","normalizeWhitespace","text","normalized","i","length","char","isQuote","isSingleQuote","isDoubleQuote","normalizeQuote","stripLastOccurrence","textToStrip","index","lastIndexOf","substring","insertBeforeLastWhitespace","textToInsert","insertAtIndex"],"mappings":"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","sourcesContent":["\nconst SINGLE_QUOTES = {\n  '\\'': true, // quote\n  '\\u2018': true, // quote left\n  '\\u2019': true, // quote right\n  '\\u0060': true, // grave accent\n  '\\u00B4': true // acute accent\n}\n\nconst DOUBLE_QUOTES = {\n  '\"': true,\n  '\\u201C': true, // double quote left\n  '\\u201D': true // double quote right\n}\n\n/**\n * Check if the given character contains an alpha character, a-z, A-Z, _\n * @param {string} c\n * @return {boolean}\n */\nexport function isAlpha (c) {\n  return ALPHA_REGEX.test(c)\n}\n\nconst ALPHA_REGEX = /^[a-zA-Z_]$/\n\n/**\n * Check if the given character contains a hexadecimal character 0-9, a-f, A-F\n * @param {string} c\n * @return {boolean}\n */\nexport function isHex (c) {\n  return HEX_REGEX.test(c)\n}\n\nconst HEX_REGEX = /^[0-9a-fA-F]$/\n\n/**\n * checks if the given char c is a digit\n * @param {string} c\n * @return {boolean}\n */\nexport function isDigit (c) {\n  return DIGIT_REGEX.test(c)\n}\n\nconst DIGIT_REGEX = /^[0-9]$/\n\n/**\n * Check if the given character is a whitespace character like space, tab, or\n * newline\n * @param {string} c\n * @return {boolean}\n */\nexport function isWhitespace (c) {\n  return c === ' ' || c === '\\t' || c === '\\n' || c === '\\r'\n}\n\n/**\n * Check if the given character is a special whitespace character, some\n * unicode variant\n * @param {string} c\n * @return {boolean}\n */\nexport function isSpecialWhitespace (c) {\n  return (\n    c === '\\u00A0' ||\n    (c >= '\\u2000' && c <= '\\u200A') ||\n    c === '\\u202F' ||\n    c === '\\u205F' ||\n    c === '\\u3000'\n  )\n}\n\n/**\n * Replace speical whitespace characters with regular spaces\n * @param {string} text\n * @returns {string}\n */\nexport function normalizeWhitespace (text) {\n  let normalized = ''\n\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i]\n    normalized += isSpecialWhitespace(char)\n      ? ' '\n      : char\n  }\n\n  return normalized\n}\n\n/**\n * Test whether the given character is a quote or double quote character.\n * Also tests for special variants of quotes.\n * @param {string} c\n * @returns {boolean}\n */\nexport function isQuote (c) {\n  return SINGLE_QUOTES[c] === true || DOUBLE_QUOTES[c] === true\n}\n\n/**\n * Test whether the given character is a single quote character.\n * Also tests for special variants of single quotes.\n * @param {string} c\n * @returns {boolean}\n */\nexport function isSingleQuote (c) {\n  return SINGLE_QUOTES[c] === true\n}\n\n/**\n * Test whether the given character is a double quote character.\n * Also tests for special variants of double quotes.\n * @param {string} c\n * @returns {boolean}\n */\nexport function isDoubleQuote (c) {\n  return DOUBLE_QUOTES[c] === true\n}\n\n/**\n * Normalize special double or single quote characters to their regular\n * variant ' or \"\n * @param {string} c\n * @returns {string}\n */\nexport function normalizeQuote (c) {\n  if (SINGLE_QUOTES[c] === true) {\n    return '\\''\n  }\n\n  if (DOUBLE_QUOTES[c] === true) {\n    return '\"'\n  }\n\n  return c\n}\n\n/**\n * Strip last occurrence of textToStrip from text\n * @param {string} text\n * @param {string} textToStrip\n * @returns {string}\n */\nexport function stripLastOccurrence (text, textToStrip) {\n  const index = text.lastIndexOf(textToStrip)\n  return (index !== -1)\n    ? text.substring(0, index) + text.substring(index + 1)\n    : text\n}\n\n/**\n * Insert textToInsert into text before the last whitespace in text\n * @param {string} text\n * @param {string} textToInsert\n * @returns {string}\n */\nexport function insertBeforeLastWhitespace (text, textToInsert) {\n  let index = text.length\n\n  if (!isWhitespace(text[index - 1])) {\n    // no trailing whitespaces\n    return text + textToInsert\n  }\n\n  while (isWhitespace(text[index - 1])) {\n    index--\n  }\n\n  return text.substring(0, index) + textToInsert + text.substring(index)\n}\n\n/**\n * Insert textToInsert at index in text\n * @param {string} text\n * @param {string} textToInsert\n * @param {number} index\n * @returns {string}\n */\nexport function insertAtIndex (text, textToInsert, index) {\n  return text.substring(0, index) + textToInsert + text.substring(index)\n}\n"],"file":"stringUtils.js"}